<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Swarm Heatmap — Relative Intensity</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; background:#0b0f14; color:#e6edf3; font-family: ui-sans-serif,system-ui,Arial; }
    #toolbar { padding: 10px 14px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; border-bottom: 1px solid #1f2a36; }
    /* Map wrapper so we can overlay the Solar Wind card */
    #map-wrap { position: relative; height: calc(100% - 64px); }
    #map { height: 100%; }
    select, input, button { background:#0f1620; color:#e6edf3; border:1px solid #223140; border-radius:8px; padding:6px 10px; }
    button { cursor:pointer; }
    .pill { padding:4px 8px; border-radius:999px; border:1px solid #223140; font-size:12px; color:#9fb3c8; }
    label { display:flex; gap:6px; align-items:center; }
    noscript { display:block; padding:12px 14px; color:#fca5a5; }

    /* ---- Solar Wind card styles ---- */
    .sw-card{
      font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: #0f131a; color: #e8eef7;
      border: 1px solid #243044; border-radius: 12px;
      padding: 12px; width: 260px; box-shadow: 0 2px 6px rgba(0,0,0,.25);
    }
    .sw-overlay{ position: absolute; top: 12px; right: 12px; z-index: 1000; }
    .sw-card__header{ display:flex; justify-content:space-between; align-items:center; font-weight:600; margin-bottom:6px; }
    .sw-card__time{ opacity:.8; font-size:12px; margin-bottom:8px }
    .sw-grid{ display:grid; grid-template-columns:1fr 1fr; gap:8px }
    .sw-metric__label{ opacity:.7; font-size:12px }
    .sw-metric__value{ font-size:16px; font-weight:600 }
    .sw-unit{ opacity:.6; font-weight:400; margin-left:4px }
    .sw-risk{ display:inline-block; width:12px; height:12px; border-radius:50%; border:1px solid rgba(255,255,255,.2) }
    .sw-risk--green{ background:#19c37d }
    .sw-risk--yellow{ background:#f5b83d }
    .sw-risk--red{ background:#ef4146 }
    .sw-spark{ width:100%; height:36px; margin-top:8px; display:block; opacity:.9 }
  </style>
</head>
<body>
  <div id="toolbar">
    <span class="pill">Solionyx Heatmap</span>

    <label>Start (UTC):
      <input id="startDate" type="date" />
    </label>
    <label>End (UTC):
      <input id="endDate" type="date" />
    </label>

    <label>Metric:
      <select id="metric">
        <option value="dbdt_max" selected>Max |dB/dt| per minute (µT/s)</option>
        <option value="f_mean">Mean |B| per minute (µT)</option>
      </select>
    </label>

    <label>Grid:
      <select id="grid">
        <option value="2,5" selected>2° × 5°</option>
        <option value="1,2">1° × 2°</option>
        <option value="4,10">4° × 10°</option>
      </select>
    </label>

    <label>Scale:
      <select id="scaleMode">
        <option value="p95" selected>Relative (95th pct)</option>
        <option value="abs">Absolute</option>
      </select>
    </label>
    <label title="Only used if Scale=Absolute">Max:
      <input id="absMax" type="number" step="0.01" placeholder="e.g. 0.5" style="width:90px" disabled />
    </label>

    <label title="Ignore cells with too few minutes">
      Min hits:
      <input id="minHits" type="number" min="1" value="5" style="width:70px" />
    </label>

    <button id="refresh">Apply</button>
    <button id="download">Download CSV</button>
    <span id="status" style="margin-left:auto; font-size:12px; color:#9fb3c8;"></span>
  </div>

  <!-- Map + Solar Wind overlay -->
  <div id="map-wrap">
    <div id="map"></div>

    <!-- Solar Wind Card (overlay) -->
    <div id="sw-card" class="sw-card sw-overlay">
      <div class="sw-card__header">
        <span>Solar wind (L1)</span>
        <span id="sw-risk" class="sw-risk sw-risk--green" title="Coupling risk"></span>
      </div>

      <div class="sw-card__time" id="sw-time">—</div>

      <div class="sw-grid">
        <div class="sw-metric">
          <div class="sw-metric__label">Bz (GSM)</div>
          <div class="sw-metric__value"><span id="sw-bz">—</span> <span class="sw-unit">nT</span></div>
        </div>
        <div class="sw-metric">
          <div class="sw-metric__label">Speed</div>
          <div class="sw-metric__value"><span id="sw-v">—</span> <span class="sw-unit">km/s</span></div>
        </div>
        <div class="sw-metric">
          <div class="sw-metric__label">Dyn. pressure</div>
          <div class="sw-metric__value"><span id="sw-p">—</span> <span class="sw-unit">nPa</span></div>
        </div>
        <div class="sw-metric">
          <div class="sw-metric__label">Density</div>
          <div class="sw-metric__value"><span id="sw-n">—</span> <span class="sw-unit">cm³</span></div>
        </div>
      </div>

      <svg id="sw-spark-bz" class="sw-spark" viewBox="0 0 160 36" preserveAspectRatio="none" aria-label="Bz sparkline"></svg>
    </div>
  </div>

  <noscript>Enable JavaScript to view the map.</noscript>

  <!-- Libs -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.5/dist/umd/supabase.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <!-- App -->
  <script>
    // Supabase (anon only)
    const SUPABASE_URL = "https://uajnhkmwfskddeizcpir.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVham5oa213ZnNrZGRlaXpjcGlyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI2ODU5NzIsImV4cCI6MjA2ODI2MTk3Mn0.hNCTx5Q7rA_OgdK5xeWwJhY5FZjDwubSpcjkVI2gR0U";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { db: { schema: "geomag" } });

    // Map
    const map = L.map('map', { worldCopyJump: true, minZoom: 2 }).setView([20, 0], 2);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: "© OpenStreetMap", maxZoom: 6 }).addTo(map);
    let heat = null, lastData = [];

    // DOM refs
    const statusEl = document.getElementById('status');
    const metricEl = document.getElementById('metric');
    const gridEl   = document.getElementById('grid');
    const scaleEl  = document.getElementById('scaleMode');
    const absMaxEl = document.getElementById('absMax');
    const minHitsEl= document.getElementById('minHits');
    const startEl  = document.getElementById('startDate');
    const endEl    = document.getElementById('endDate');

    // Default date range = last 7 days (UTC)
    function dToISODate(d){ return d.toISOString().slice(0,10); }
    (function setDefaultDates(){
      const end = new Date();
      const start = new Date(end.getTime() - 7*24*3600*1000);
      endEl.value = dToISODate(end);
      startEl.value = dToISODate(start);
    })();

    // Helpers: build UTC midnights; end is exclusive (add 1 day to include selected end date)
    function dateInputToUtcMidnight(dateStr, addDays=0){
      const [y,m,d] = dateStr.split('-').map(n=>parseInt(n,10));
      const dt = new Date(Date.UTC(y, m-1, d + addDays, 0, 0, 0));
      return dt.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    scaleEl.addEventListener('change', () => {
      absMaxEl.disabled = (scaleEl.value !== 'abs');
    });

    async function loadHeat() {
      try {
        const startStr = startEl.value;
        const endStr   = endEl.value;
        if (!startStr || !endStr) { alert('Pick start and end dates.'); return; }

        const startISO = dateInputToUtcMidnight(startStr, 0);
        const endISO   = dateInputToUtcMidnight(endStr, 1); // inclusive of end date

        if (new Date(startISO) >= new Date(endISO)) { alert('End must be after start.'); return; }

        const metric = metricEl.value;
        const [dlat, dlon] = gridEl.value.split(',').map(parseFloat);
        const minHits = parseInt(minHitsEl.value || '0', 10);

        statusEl.textContent = `Loading ${metric} • ${startStr} → ${endStr} (UTC)…`;

        const { data, error } = await supabase.rpc('grid_heatmap_1m', {
          start_ts: startISO, end_ts: endISO, dlat, dlon, metric
        });

        if (error) throw new Error(error.message || 'RPC error');

        let rows = Array.isArray(data) ? data : [];
        if (minHits > 1) rows = rows.filter(r => (r.hits||0) >= minHits);

        if (!rows.length) {
          statusEl.textContent = 'No data in that range.';
          if (heat) map.removeLayer(heat);
          lastData = [];
          return;
        }

        // Scaling
        let scaleFn, scaleNote;
        if (scaleEl.value === 'abs') {
          const maxVal = parseFloat(absMaxEl.value);
          if (!isFinite(maxVal) || maxVal <= 0) { alert('Enter a positive Max for absolute scale.'); return; }
          scaleFn = v => Math.max(0, Math.min(1, (v || 0) / maxVal));
          scaleNote = `abs max=${maxVal}`;
        } else {
          const values = rows.map(r => r.value ?? 0).filter(Number.isFinite).sort((a,b)=>a-b);
          const p95 = values[Math.floor(0.95*values.length)] || 1;
          scaleFn = v => Math.min(1, (v || 0) / (p95 || 1));
          scaleNote = `p95=${p95.toFixed(3)}`;
        }

        const points = rows.map(r => [r.lat_bin, r.lon_bin, scaleFn(r.value)]);
        if (heat) map.removeLayer(heat);
        heat = L.heatLayer(points, { radius: 18, blur: 15, maxZoom: 6 }).addTo(map);

        const hits = rows.reduce((s,r)=>s+(r.hits||0),0);
        statusEl.textContent = `${rows.length} cells, ${hits} minute-bins • ${scaleNote} • ${metric}`;
        lastData = rows;

        // Sync the Solar Wind card to the end of the selected range
        window.SolarWind?.onTimeChanged(new Date(endISO));

      } catch (e) {
        console.error(e);
        statusEl.textContent = `Error: ${e.message}`;
        if (heat) map.removeLayer(heat);
        lastData = [];
      }
    }

    function downloadCSV() {
      if (!lastData.length) { alert('No data to export.'); return; }
      const header = ['lat_bin','lon_bin','value','hits'];
      const rows = lastData.map(r => [r.lat_bin, r.lon_bin, r.value ?? '', r.hits ?? '']);
      const csv = [header, ...rows].map(arr => arr.join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = Object.assign(document.createElement('a'), { href: url, download: 'heatmap.csv' });
      a.click(); URL.revokeObjectURL(url);
    }

    document.getElementById('refresh').addEventListener('click', loadHeat);
    document.getElementById('download').addEventListener('click', downloadCSV);

    // Initial render
    loadHeat();
  </script>

  <!-- Solar Wind Card logic (JSON for recent, Supabase for history) -->
  <script>
  (function(){
    const state = { series: [], lastFetchTs: 0, refreshMs: 2*60*1000 };
    const el = {
      time: document.getElementById('sw-time'),
      bz:   document.getElementById('sw-bz'),
      v:    document.getElementById('sw-v'),
      p:    document.getElementById('sw-p'),
      n:    document.getElementById('sw-n'),
      risk: document.getElementById('sw-risk'),
      sparkBz: document.getElementById('sw-spark-bz'),
    };

    // ---- Load recent JSON (last ~6h snapshot updated by your Action)
    async function loadSolarWindRecent() {
      const url = `./data/solar_wind_last6h.json?ts=${Date.now()}`;
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const raw = await res.json();
        state.series = raw.map(d => ({
          t: new Date(d.time),
          bz: toNum(d.bz_gsm), pdyn: toNum(d.pdyn_npa),
          v: toNum(d.speed),    n: toNum(d.density),
        })).filter(d => !isNaN(d.t.getTime()))
          .sort((a,b) => a.t - b.t);
        state.lastFetchTs = Date.now();
        if (state.series.length) {
          const latest = state.series[state.series.length - 1];
          updateCard(latest);
          drawSparkline(el.sparkBz, state.series.map(s => s.bz));
        }
      } catch (e) { console.warn('Solar wind JSON load failed:', e); }
    }

    function toNum(x){ const v = Number(x); return Number.isFinite(v) ? v : null; }

    // Binary search nearest by time from the loaded JSON series
    function nearestFromSeries(ts){
      const s = state.series; if (!s.length) return null;
      let lo=0, hi=s.length-1;
      while (lo < hi){ const mid=(lo+hi)>>1; (s[mid].t < ts) ? (lo=mid+1) : (hi=mid); }
      const i2 = Math.max(0, Math.min(s.length-1, lo));
      const i1 = Math.max(0, i2-1);
      return Math.abs(s[i1].t - ts) < Math.abs(s[i2].t - ts) ? s[i1] : s[i2];
    }

    // Query Supabase for the *nearest* minute to ts (within a 2h window)
    async function fetchNearestFromDB(ts){
      if (typeof window.supabase === 'undefined') return null;
      const pub = (typeof supabase.schema === 'function') ? supabase.schema('public') : supabase;
      const iso = ts.toISOString().replace(/\.\d{3}Z$/, 'Z');

      // 1) sample at/before ts
      const q1 = await pub.from('solar_wind_minute')
        .select('time,density,speed,temperature,bx_gsm,by_gsm,bz_gsm,bt,pdyn_npa,bz_south,vbz,clock_angle_rad,newell_proxy')
        .lte('time', iso)
        .gte('time', new Date(ts.getTime() - 2*60*60*1000).toISOString())
        .order('time', { ascending: false })
        .limit(1);

      // 2) sample at/after ts
      const q2 = await pub.from('solar_wind_minute')
        .select('time,density,speed,temperature,bx_gsm,by_gsm,bz_gsm,bt,pdyn_npa,bz_south,vbz,clock_angle_rad,newell_proxy')
        .gte('time', iso)
        .lte('time', new Date(ts.getTime() + 2*60*60*1000).toISOString())
        .order('time', { ascending: true })
        .limit(1);

      const a = (q1.data && q1.data[0]) ? q1.data[0] : null;
      const b = (q2.data && q2.data[0]) ? q2.data[0] : null;
      if (!a && !b) return null;

      const da = a ? Math.abs(new Date(a.time) - ts) : Infinity;
      const db = b ? Math.abs(new Date(b.time) - ts) : Infinity;
      const r = (da <= db) ? a : b;

      return {
        t: new Date(r.time),
        bz: toNum(r.bz_gsm),
        pdyn: toNum(r.pdyn_npa),
        v: toNum(r.speed),
        n: toNum(r.density),
      };
    }

    function solarWindRisk(bz, pdyn, v){
      const bzSouth = Math.min(0, bz ?? 0);
      const bzRisk = (bzSouth <= -10) ? 2 : (bzSouth <= -5 ? 1 : 0);
      const pRisk  = (pdyn ?? 0) >= 6 ? 2 : ((pdyn ?? 0) >= 3 ? 1 : 0);
      const vRisk  = (v ?? 0) >= 700 ? 2 : ((v ?? 0) >= 500 ? 1 : 0);
      const score = bzRisk*0.5 + pRisk*0.3 + vRisk*0.2;
      return score >= 1.3 ? 'red' : score >= 0.7 ? 'yellow' : 'green';
    }

    function fmt(x, d0=0){ if (x == null || !Number.isFinite(x)) return '—'; return (Math.abs(x) < 10 ? x.toFixed(1) : x.toFixed(d0)); }
    function fmtTime(d){ try{ return d.toLocaleString([], {hour12:false}); } catch { return '—'; } }
    function setRisk(color){
      el.risk.classList.remove('sw-risk--green','sw-risk--yellow','sw-risk--red');
      el.risk.classList.add(color === 'red' ? 'sw-risk--red' : color === 'yellow' ? 'sw-risk--yellow' : 'sw-risk--green');
    }
    function updateCard(s){
      el.time.textContent = fmtTime(s.t);
      el.bz.textContent = fmt(s.bz, 1);
      el.v.textContent  = fmt(s.v, 0);
      el.p.textContent  = fmt(s.pdyn, 1);
      el.n.textContent  = fmt(s.n, 1);
      setRisk(solarWindRisk(s.bz, s.pdyn, s.v));
    }

    // Tiny SVG sparkline for Bz
    function drawSparkline(svg, values){
      if (!svg || !values?.length) return;
      const W=160,H=36,P=2,n=values.length;
      const xs=i=>P+(i*(W-2*P))/Math.max(1,n-1);
      let min=Infinity,max=-Infinity; for(const v of values){ if(v==null) continue; min=Math.min(min,v); max=Math.max(max,v); }
      if(!isFinite(min)||!isFinite(max)||min===max){ min=-1; max=1; }
      const y=v=>{ const t=(v-min)/(max-min); return H-P - t*(H-2*P); };
      let d=''; for(let i=0;i<n;i++){ const v = values[i] ?? 0; d += (i?'L':'M') + xs(i) + ' ' + y(v) + ' '; }
      svg.innerHTML = `<path d="${d}" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.9"/>
                       <line x1="${P}" y1="${y(0)}" x2="${W-P}" y2="${y(0)}" stroke="currentColor" stroke-width="0.5" opacity="0.3"/>`;
    }

    function isRecent(ts){
      const now = Date.now();
      const sevenDays = 7 * 24 * 3600 * 1000;
      return (now - ts.getTime()) <= (sevenDays - 12*3600*1000); // ~6.5d for safety
    }

    // Public hook – call this with the heatmap’s active time
    window.SolarWind = {
      onTimeChanged: async (ts)=>{
        if (!(ts instanceof Date)) ts = new Date(ts);
        // If recent, use the preloaded JSON series; else query Supabase
        if (isRecent(ts) && state.series.length){
          const s = nearestFromSeries(ts);
          if (s) updateCard(s);
          if (Date.now() - state.lastFetchTs > state.refreshMs) loadSolarWindRecent();
        } else {
          const s = await fetchNearestFromDB(ts);
          if (s) updateCard(s);
        }
      }
    };

    document.addEventListener('DOMContentLoaded', loadSolarWindRecent);
    setInterval(loadSolarWindRecent, state.refreshMs);
  })();
  </script>
</body>
</html>
