<script>
  // 1) Supabase project creds (anon key only)
  const SUPABASE_URL = "https://uajnhkmwfskddeizcpir.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVham5oa213ZnNrZGRlaXpjcGlyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI2ODU5NzIsImV4cCI6MjA2ODI2MTk3Mn0.hNCTx5Q7rA_OgdK5xeWwJhY5FZjDwubSpcjkVI2gR0U";

  // 2) Client scoped to geomag schema
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { db: { schema: "geomag" } });

  // 3) Leaflet map
  const map = L.map('map', { worldCopyJump: true, minZoom: 2 }).setView([20, 0], 2);
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: "© OpenStreetMap", maxZoom: 6 }).addTo(map);
  let heat = null;
  let lastData = [];

  const statusEl = document.getElementById('status');
  const hoursEl  = document.getElementById('hours');
  const metricEl = document.getElementById('metric');
  const gridEl   = document.getElementById('grid');

  function isoNoMs(d){ return d.toISOString().replace(/\.\d{3}Z$/, 'Z'); }

  async function loadHeat() {
    const hours = parseInt(hoursEl.value, 10);
    const metric = metricEl.value;
    const [dlat, dlon] = gridEl.value.split(',').map(parseFloat);

    const end = new Date();
    const start = new Date(end.getTime() - hours*3600*1000);
    statusEl.textContent = `Loading ${metric} over last ${hours}h…`;

    const { data, error } = await supabase.rpc('grid_heatmap_1m', {
      start_ts: isoNoMs(start),
      end_ts: isoNoMs(end),
      dlat, dlon, metric
    });

    if (error) {
      console.error(error);
      statusEl.textContent = `Error: ${error.message}`;
      if (heat) map.removeLayer(heat);
      lastData = [];
      return;
    }
    if (!Array.isArray(data) || data.length === 0) {
      statusEl.textContent = 'No data in that window.';
      if (heat) map.removeLayer(heat);
      lastData = [];
      return;
    }

    // Normalize intensity to 0..1 using 95th percentile
    const values = data.map(r => r.value ?? 0).filter(Number.isFinite).sort((a,b)=>a-b);
    const p95 = values[Math.floor(0.95*values.length)] || 1;
    const scale = v => Math.min(1, (v / (p95 || 1)));

    const points = data.map(r => [r.lat_bin, r.lon_bin, scale(r.value || 0)]);
    if (heat) map.removeLayer(heat);
    heat = L.heatLayer(points, { radius: 18, blur: 15, maxZoom: 6 }).addTo(map);

    const hits = data.reduce((s,r)=>s+(r.hits||0),0);
    statusEl.textContent = `${data.length} cells, ${hits} minute-bins • p95=${p95.toFixed(2)} (${metric})`;

    lastData = data; // keep for CSV download
  }

  function downloadCSV() {
    if (!lastData.length) { alert('No data to export.'); return; }
    const rows = [['lat_bin','lon_bin','value','hits']];
    lastData.forEach(r => rows.push([r.lat_bin, r.lon_bin, r.value ?? '', r.hits ?? '']));
    const csv = rows.map(r => r.join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), { href: url, download: 'heatmap.csv' });
    a.click(); URL.revokeObjectURL(url);
  }

  document.getElementById('refresh').addEventListener('click', loadHeat);
  document.getElementById('download').addEventListener('click', downloadCSV);

  loadHeat(); // initial render
</script>
